
<<<<Nasta Kommentar>>>>>
En Spelmotor för tetris. 
<<<<Nasta Kommentar>>>>>
gameCommand är en datatype för dom input kommandon som en spelare använder i Tetris spelandet.
	Ett komando är som en knapklikning. 
	Om man vill använda sig av Delayed Auto Shift eller autorepeat bör det göras i koden som mappar spelerens input till gameCommand som en serie av knapptrykningar eller i hårdvaran. 
	LeftShift: 	flytar tetromino:n en steg till vänster 
	RightShift:	flytar tetromino:n en steg till höger
	HardDrop:	gör att tetromino:n faller ner omedelbart på den första ytan den landar på och en omedelbart Lock Down(Spelaren kan inte längre flyta eller rotera tetromino:n)
	SoftDrop:	flytar tetromino:n en steg till ner
	RotateCW: 	Roterar tetromino:n 90 grader medsols
	RotateCCW:	Roterar tetromino:n 90 grader motsols
	*Med tetromino:n syftas det på den tetromino:n som inte Lock Down, dvs den spelaren frortfarande kan flytta/rotera på.
	
<<<<Nasta Kommentar>>>>>
 REPRESENTATION CONVENTION: commands used to move tetrominos: 
   	   LeftShift: moves the tetromino one step left. 
   	   RightShift: moves the tetromino one step right. 
	   HardDrop: drops the tetromino the surface it lands on´and locks, making it impossible to move. 
	   SoftDrop: moves the tetromino one step down. 
	   RotateCW: rotates the tetromino 90 degrees clockwise. 
	   RotateCCW: rotates the tetromino 90 degrees counterclockwise.
	   REPRESENTATION INVARIANT: (none)
 	
<<<<Nasta Kommentar>>>>>
Datatype används som idenifierar för dom 7 olika typerna en ensidiga tetromino:na kan ha.
	Dom ensidiga tetromino:na får roteras men inte reflekteras. Nedan vissas endast en riknig av vare ensidiga tetromino.
	tetromino_O: 
	[][]
	[][]
	tetromino_I:
	[][][][]
	Tetromino_S:
	  [][]
	[][]
	Tetromino_Z:
	[][]
	  [][]
	Tetromino_L:
	    []
	[][][]
	Tetromino_J:
	[]
	[][][]
	Tetromino_T:
	  []
	[][][]
		
<<<<Nasta Kommentar>>>>>
 REPRESENTATION CONVENTION: different types of the following onesided tetrominos:
	   Tetromino_O: 
	   [][]
	   [][]
	   Tetromino_I:
	   [][][][]
	   Tetromino_S:
	     [][]
	   [][]
	   Tetromino_Z:
	   [][]
	     [][]
	   Tetromino_L:
	       []
	   [][][]
   	   Tetromino_J:
	   []
	   [][][]
	   Tetromino_T:
	     []
	   [][][]
   	   REPRESENTATION INVARIANT: (none)
   	
<<<<Nasta Kommentar>>>>>
  Denna datatype är tänkt att basriva dom fyra riktningar ensidig Tetromino kan ha.
		North: grund/start riktningen av en Tetromino 
		East: är 90 grader medsols eller 270 grader motsols från grund riktningen
		South: är 180 grader medsols eller 180 grader motsols från grund riktningen
		West: är 270 grader medsols eller 90 grader motsols från grund riktningen
		  
<<<<Nasta Kommentar>>>>>
 REPRESENTATION CONVENTION: directions that a onesided tetromino can have:
	   North: the initial direction
	   East: 90 degrees clockwise or 270 degrees counterclockwise from North. 
	   South: 180 degrees clockwise or 180 degrees counterclockwise from North. 
      	   West: 270 degrees clockwise or 90 degrees counterclockwise from North.
	   REPRESENTATION INVARIANT: (none)
	
<<<<Nasta Kommentar>>>>>
Denna datatyp inehåller iformation som används under rendering
<<<<Nasta Kommentar>>>>>
 REPRESENTATION CONVENTION: one of four blocks of a tetromino
   	   REPRESENTATION INVARIANT: is of type Option
 	
<<<<Nasta Kommentar>>>>>
position är en tuppel av typen int * int för att bestriva fria spelbara Tetromino:n position.
	Den första elementet av tuppeln är vilken komumn i spel matrisen.
	Den andra elementet av tuppeln är vilken rad i spel matrisen.
	
<<<<Nasta Kommentar>>>>>
TODO
<<<<Nasta Kommentar>>>>>
gamestate är immutable datatype som besriver det aktuella speltilståndet.
		gamestate har instansen gs(spel_matrisen, (aktiv_tetromino_typ, aktiv_tetromino_position, aktiv_tetromino_facing),nästkommande_tetromino_typ, clearRows)

		spel_matrisen: dom fasta block i spelplanen. När en den aktiva tetromino slutligen hamnar i Lock Down plaseras den som block i spel_matrisen.
			Om det är en NONE på en given ruta i matrisen betyder det att inget block ligger där, rutan är tom annars ligger ett fast block där
		
		aktiv_tetromino_typ: vilken type den spelbar tetromino har

		aktiv_tetromino_position: vilken position den spelbar tetromino har

		aktiv_tetromino_facing: vilken riktning den spelbar tetromino har

		nästkommande_tetromino_typ: vilken type den nästkommande tetromino kommer ha
		
<<<<Nasta Kommentar>>>>>
 REPRESENTATION CONVENTION: a gamestate with game matrix m, active tetromino type at, active tetromino position (x,y), active tetromino facing af, next tetromino type nt and clearRows clrRows is represented by (gs(m,(at,(x,y),af),nt,clrRows))
   	   REPRESENTATION INVARIANT: all blocks in m are locked. If a block in m is NONE then the place is empty, otherwise a block is locked there 
 	
<<<<Nasta Kommentar>>>>>
Skapar en matris med blocken från en tetromino_type och facing
<<<<Nasta Kommentar>>>>>
 createBlocks tt fac
	TYPE: tetromino_type -> facing -> (int * int) list
	PRE: TODO
	POST: a list of coordinates for tetromino type tt in the direction fac
	EXAMPLE: createBlocks Tetromino_T North = [(~1, 0), (0, ~1), (1, 0), (0, 0)]
	
<<<<Nasta Kommentar>>>>>
 checkRow (m, i)
	TYPE: 'a option matrix * int -> bool
	PRE: none
	POST: true if row i in matrix m is full else false
	EXAMPLE: checkRow(Vector.fromList[Vector.fromList[SOME(1),SOME(1),SOME(1)],Vector.fromList[NONE,NONE,NONE]], 0) = true
	
<<<<Nasta Kommentar>>>>>
 moveRows (m, i)
        TYPE: 'a matrix * int -> 'a matrix
        PRE: 0 <= i <= |m|
        POST: TODO
        EXAMPLE: moveRows(Vector.fromList[Vector.fromList[SOME(1),SOME(1),SOME(1)],Vector.fromList[NONE,NONE,NONE]], 1) = fromList[fromList[SOME 1, SOME 1, SOME 1], fromList[SOME 1, SOME 1, SOME 1]
        
<<<<Nasta Kommentar>>>>>

        VARIANT: i
        
<<<<Nasta Kommentar>>>>>
 deleteRow' (m, i)
        TYPE: gamestate * int -> gamestate
        PRE: 0 <= i <= |m|
        POST: if row i in matrix m is "full" then m without that row, but with an "empty" row at the top instead else m
        EXAMPLE: TODO
        
<<<<Nasta Kommentar>>>>>

        VARIANT: i
        
<<<<Nasta Kommentar>>>>>
 deleteRow g
        TYPE: gamestate -> gamestate
        PRE: TODO
        POST: if row i in matrix m is "full" then m without that row, but with an "empty" row at the top instead else m
        EXAMPLE: TODO
        
<<<<Nasta Kommentar>>>>>

	Validering av en gamestate för att undersöka om den befinersig i ett förbjudet tillstånd
	
<<<<Nasta Kommentar>>>>>
 gamestate_Validation g
        TYPE: gamestate -> bool
        PRE: TODO
        POST: true if g is allowed else false
        EXAMPLE: TODO
        
<<<<Nasta Kommentar>>>>>
lockDown_Validation state
	TYPE: gamestate -> bool
	PRE: TODO
        POST: TODO
        EXAMPLE: TODO
        
<<<<Nasta Kommentar>>>>>
Låser det aktuela blocket
<<<<Nasta Kommentar>>>>>
lockDown state
	TYPE: gamestate -> gamestate option
	PRE: TODO
        POST: TODO
        EXAMPLE: TODO
        
<<<<Nasta Kommentar>>>>>
 hardDrop state
	TYPE: gamestate -> gamestate option
	PRE: state måste vara validerad
	POST: state efter en harddrop opration
	EXAMPLE: TODO
	
<<<<Nasta Kommentar>>>>>

	VARIANT: y
	
<<<<Nasta Kommentar>>>>>
Map riktning + 90grader
<<<<Nasta Kommentar>>>>>
 rcw f
	TYPE: facing -> facing
	PRE: none
	POST: direction when direction f is rotated 90 degrees clockwise
	EXAMPLE: rcw North = East
	
<<<<Nasta Kommentar>>>>>
Map riktning - 90grader
<<<<Nasta Kommentar>>>>>
 rccw facing
	TYPE: facing -> facing
	PRE: none
	POST: direction when direction f is rotated 90 degrees counterclockwise
	EXAMPLE: rccw East = North
	
<<<<Nasta Kommentar>>>>>
 doCommand (state , command)
	TYPE: gamestate * gameCommand -> gamestate option
	PRE: TODO
	POST: give the next state after command is performed if the command is allowed on state else NONE
	EXEMPLE: TODO
	
<<<<Nasta Kommentar>>>>>
unknown command